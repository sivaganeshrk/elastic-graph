(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global['hash-it'] = factory());
}(this, (function () { 'use strict';

  /**
   * based on string passed, get the integer hash value
   * through bitwise operation (based on spinoff of dbj2
   * with enhancements for reduced collisions)
   *
   * @param string the string to get the hash value for
   * @returns the hash value
   */
  function getUniqueIntegerFromString(string) {
    var index = string.length;
    var hashA = 5381;
    var hashB = 52711;
    var charCode;

    while (index--) {
      charCode = string.charCodeAt(index);
      hashA = hashA * 33 ^ charCode;
      hashB = hashB * 33 ^ charCode;
    }

    return (hashA >>> 0) * 4096 + (hashB >>> 0);
  }

  var getClassTypes = function getClassTypes(classes, reversed) {
    return classes.reduce(function (map, className) {
      var toStringClassName = "[object " + className + "]";

      if (reversed) {
        map[toStringClassName] = className;
      } else {
        map[className] = toStringClassName;
      }

      return map;
    }, {});
  };

  var getFlags = function getFlags(flags) {
    return flags.reduce(function (flag, item) {
      flag[item] = true;
      return flag;
    }, {});
  };

  var OBJECT_CLASSES = [// self tags
  'Array', 'Arguments', 'Object', // toString tags
  'RegExp', 'Symbol', // iterable tags
  'Map', 'Set', 'Date', 'Error', 'Event', // bailout tags
  'Generator', 'Promise', 'WeakMap', 'WeakSet', 'DocumentFragment', // typed array tags
  'Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'ArrayBuffer', 'DataView', 'DocumentFragment', 'Window', // primitive classes, e.g. new String()
  'String', 'Number', 'Boolean', 'Function', 'Undefined', 'GeneratorFunction', 'BigInt', 'Null'];
  var OBJECT_CLASS_TYPE = getClassTypes(OBJECT_CLASSES, false);
  var OBJECT_CLASS = getClassTypes(OBJECT_CLASSES, true);
  var BAILOUT_TAGS = getFlags([OBJECT_CLASS_TYPE.Generator, OBJECT_CLASS_TYPE.Promise, OBJECT_CLASS_TYPE.WeakMap, OBJECT_CLASS_TYPE.WeakSet]);
  var ITERABLE_TAGS = getFlags([OBJECT_CLASS_TYPE.Map, OBJECT_CLASS_TYPE.Set]);
  var NORMALIZED_TAGS = getFlags([OBJECT_CLASS_TYPE.Date, OBJECT_CLASS_TYPE.RegExp]);
  var PRIMITIVE_TAGS = getFlags(['bigint', 'boolean', 'function', 'number', 'string', 'undefined']);
  var SELF_TAGS = getFlags([OBJECT_CLASS_TYPE.Arguments, OBJECT_CLASS_TYPE.Array]);
  var TO_STRING_TAGS = getFlags([OBJECT_CLASS_TYPE.RegExp, OBJECT_CLASS_TYPE.Symbol]);
  var TYPED_ARRAY_TAGS = getFlags([OBJECT_CLASS_TYPE.Float32Array, OBJECT_CLASS_TYPE.Float64Array, OBJECT_CLASS_TYPE.Int8Array, OBJECT_CLASS_TYPE.Int16Array, OBJECT_CLASS_TYPE.Int32Array, OBJECT_CLASS_TYPE.Uint8Array, OBJECT_CLASS_TYPE.Uint8ClampedArray, OBJECT_CLASS_TYPE.Uint16Array, OBJECT_CLASS_TYPE.Uint32Array]);

  var HAS_BUFFER_FROM_SUPPORT = typeof Buffer !== 'undefined' && typeof Buffer.from === 'function';
  var HAS_UINT16ARRAY_SUPPORT = typeof Uint16Array === 'function';
  /**
   * get the string value of the buffer passed based on a Buffer
   *
   * @param buffer the array buffer to convert
   * @returns the stringified buffer
   */

  function getStringifiedArrayBufferFallback(buffer) {
    return String.fromCharCode.apply(null, new Uint16Array(buffer));
  }
  /**
   * get the string value of the buffer passed based on a Uint16Array
   *
   * @param buffer the array buffer to convert
   * @returns the stringified buffer
   */

  function getStringifiedArrayBufferModern(buffer) {
    return Buffer.from(buffer).toString('utf8');
  }
  /**
   * return a placeholder when no arraybuffer support exists
   *
   * @returns the placeholder
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars

  function getStringifiedArrayBufferNoSupport(buffer) {
    return '';
  }
  /**
   * @function getStringifiedArrayBuffer
   *
   * @description
   * get the string value of the buffer passed
   *
   * @param {ArrayBuffer} buffer the array buffer to convert
   * @returns {string} the stringified buffer
   */

  var getStringifiedArrayBuffer = function () {
    if (HAS_BUFFER_FROM_SUPPORT) {
      return getStringifiedArrayBufferModern;
    }

    if (HAS_UINT16ARRAY_SUPPORT) {
      return getStringifiedArrayBufferFallback;
    }

    return getStringifiedArrayBufferNoSupport;
  }();

  var XML_ELEMENT_REGEXP = /\[object ([HTML|SVG](.*)Element)\]/;
  var toString = Object.prototype.toString;
  var keys = Object.keys;
  /**
   * get the event object sorted by its properties
   *
   * @param event the event to sort
   * @returns the event object with all properties sorted
   */

  function getSortedEvent(event) {
    return {
      bubbles: event.bubbles,
      cancelBubble: event.cancelBubble,
      cancelable: event.cancelable,
      composed: event.composed,
      currentTarget: event.currentTarget,
      defaultPrevented: event.defaultPrevented,
      eventPhase: event.eventPhase,
      isTrusted: event.isTrusted,
      returnValue: event.returnValue,
      target: event.target,
      type: event.type
    };
  }
  /**
   * get the sort result based on the two values to compare
   *
   * @param first the first value to compare
   * @param second the second value to compare
   * @returns should the value be sorted
   */


  function shouldSort(first, second) {
    return first > second;
  }
  /**
   * get the sort result based on the two pairs to compare
   *
   * @param firstPair the first pair to compare
   * @param secondPair the second pair to compare
   * @returns should the value be sorted
   */


  function shouldSortPair(firstPair, secondPair) {
    return firstPair[0] > secondPair[0];
  }
  /**
   * sort the array based on the fn passed
   *
   * @param array the array to sort
   * @param fn the sorting function
   * @returns the sorted array
   */


  function sort(array, fn) {
    var subIndex;
    var value;

    for (var index = 0; index < array.length; ++index) {
      value = array[index];

      for (subIndex = index - 1; ~subIndex && fn(array[subIndex], value); --subIndex) {
        array[subIndex + 1] = array[subIndex];
      }

      array[subIndex + 1] = value;
    }

    return array;
  }
  /**
   * get the pairs in the map for stringification
   *
   * @param map the map to get the pairs for
   * @returns the sorted, stringified map
   */


  function getSortedMap(map, cache, keys) {
    var entries = [];
    map.forEach(function (value, key) {
      entries.push([stringify(key, cache, keys), stringify(value, cache, keys)]);
    });
    sort(entries, shouldSortPair);

    for (var index = 0, entry; index < entries.length; ++index) {
      entry = entries[index];
      entries[index] = "[" + entry[0] + "," + entry[1] + "]";
    }

    return "Map|[" + entries.join(',') + "]";
  }
  /**
   * get the values in the set for stringification
   *
   * @param set the set to get the values for
   * @returns the sorted, stringified set
   */


  function getSortedSet(set, cache, keys) {
    var entries = [];
    set.forEach(function (value) {
      entries.push(stringify(value, cache, keys));
    });
    sort(entries, shouldSort);
    return "Set|[" + entries.join(',') + "]";
  }
  /**
   * get the object with the keys sorted
   *
   * @param object the object to sort
   * @returns the sorted object
   */


  function getSortedObject(object) {
    var objectKeys = sort(keys(object), shouldSort);
    var newObject = {};
    var key;

    for (var index = 0; index < objectKeys.length; ++index) {
      key = objectKeys[index];
      newObject[key] = object[key];
    }

    return newObject;
  }
  /**
   * build a string based on all the fragment's children
   *
   * @param fragment the fragment to stringify
   * @returns the stringified fragment
   */


  function getStringifiedDocumentFragment(fragment) {
    var children = fragment.children;
    var innerHTML = [];

    for (var index = 0; index < children.length; ++index) {
      innerHTML.push(children[index].outerHTML);
    }

    return innerHTML.join(',');
  }
  /**
   * get the index after that of the value match in the array (faster than
   * native indexOf) to determine the cutoff index for the `splice()` call.
   *
   * @param array the array to get the index of the value at
   * @param value the value to match
   * @returns the index after the value match in the array
   */


  function getCutoffIndex(array, value) {
    for (var index = 0; index < array.length; ++index) {
      if (array[index] === value) {
        return index + 1;
      }
    }

    return 0;
  }
  /**
   * get the value normalized for stringification
   *
   * @param value the value to normalize
   * @param sortedCache the cache of sorted objects
   * @param passedTag the previously-calculated tag
   * @returns the normalized value
   */


  function getNormalizedValue(value, cache, keys, passedTag) {
    if (!passedTag) {
      var type = typeof value;

      if (PRIMITIVE_TAGS[type]) {
        return type + "|" + value;
      }

      if (value === null) {
        return value + "|" + value;
      }
    }

    var tag = passedTag || toString.call(value);

    if (SELF_TAGS[tag]) {
      return value;
    }

    if (tag === OBJECT_CLASS_TYPE.Object) {
      return getSortedObject(value);
    }

    if (TO_STRING_TAGS[tag]) {
      return OBJECT_CLASS[tag] + "|" + value.toString();
    }

    if (ITERABLE_TAGS[tag]) {
      return value instanceof Map ? getSortedMap(value, cache, keys) : getSortedSet(value, cache, keys);
    }

    if (tag === OBJECT_CLASS_TYPE.Date) {
      return OBJECT_CLASS[tag] + "|" + value.getTime();
    }

    if (tag === OBJECT_CLASS_TYPE.Error) {
      return OBJECT_CLASS[tag] + "|" + value.stack;
    }

    if (tag === OBJECT_CLASS_TYPE.Event) {
      return getSortedEvent(value);
    }

    if (BAILOUT_TAGS[tag]) {
      return OBJECT_CLASS[tag] + "|NOT_ENUMERABLE";
    }

    if (XML_ELEMENT_REGEXP.test(tag)) {
      return tag.slice(8, -1) + "|" + value.outerHTML;
    }

    if (tag === OBJECT_CLASS_TYPE.DocumentFragment) {
      return OBJECT_CLASS[tag] + "|" + getStringifiedDocumentFragment(value);
    }

    if (TYPED_ARRAY_TAGS[tag]) {
      return OBJECT_CLASS[tag] + "|" + value.join(',');
    }

    if (tag === OBJECT_CLASS_TYPE.ArrayBuffer) {
      return OBJECT_CLASS[tag] + "|" + getStringifiedArrayBuffer(value);
    }

    if (tag === OBJECT_CLASS_TYPE.DataView) {
      return OBJECT_CLASS[tag] + "|" + getStringifiedArrayBuffer(value.buffer);
    }

    return value;
  }
  /**
   * create the replacer function used for stringification
   *
   * @param sortedCache the cache to use for sorting objects
   * @returns function getting the normalized value
   */


  function createReplacer(cache, keys) {
    if (cache === void 0) {
      cache = [];
    }

    if (keys === void 0) {
      keys = [];
    }

    return function (key, value) {
      if (typeof value === 'object') {
        if (cache.length) {
          var thisCutoff = getCutoffIndex(cache, this);

          if (thisCutoff === 0) {
            cache.push(this);
          } else {
            cache.splice(thisCutoff);
            keys.splice(thisCutoff);
          }

          keys.push(key);
          var valueCutoff = getCutoffIndex(cache, value);

          if (valueCutoff !== 0) {
            return "[~" + (keys.slice(0, valueCutoff).join('.') || '.') + "]";
          }

          cache.push(value);
        } else {
          cache[0] = value;
          keys[0] = key;
        }
      }

      if (key && this[key] instanceof Date) {
        return getNormalizedValue(this[key], cache, keys, OBJECT_CLASS_TYPE.Date);
      }

      return getNormalizedValue(value, cache, keys);
    };
  }
  /**
   * stringify the value based on the options passed
   *
   * @param value the value to stringify
   * @returns the stringified value
   */


  function stringify(value, cache, keys) {
    if (!value || typeof value !== 'object') {
      return getNormalizedValue(value, cache, keys);
    }

    var tag = toString.call(value);

    if (NORMALIZED_TAGS[tag]) {
      return getNormalizedValue(value, cache, keys, tag);
    }

    return JSON.stringify(value, createReplacer(cache, keys));
  }

  /**
   * hash the value passed to a unique, consistent hash value
   *
   * @param value the value to hash
   * @returns the object hash
   */

  function hash(value) {
    return getUniqueIntegerFromString(stringify(value));
  }

  function is(value, otherValue) {
    return hash(value) === hash(otherValue);
  }

  function isAll(value) {
    for (var index = 0; index < (arguments.length <= 1 ? 0 : arguments.length - 1); ++index) {
      if (!is(value, index + 1 < 1 || arguments.length <= index + 1 ? undefined : arguments[index + 1])) {
        return false;
      }
    }

    return true;
  }

  function isAny(value) {
    for (var index = 0; index < (arguments.length <= 1 ? 0 : arguments.length - 1); ++index) {
      if (is(value, index + 1 < 1 || arguments.length <= index + 1 ? undefined : arguments[index + 1])) {
        return true;
      }
    }

    return false;
  }

  function isNot(value, otherValue) {
    return hash(value) !== hash(otherValue);
  }

  is.all = isAll;
  is.any = isAny;
  is.not = isNot;
  hash.is = is;

  return hash;

})));
//# sourceMappingURL=hash-it.js.map
